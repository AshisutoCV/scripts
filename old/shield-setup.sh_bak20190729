#!/bin/bash

LOGFILE="install.log"
BRANCH="Staging"
ERICOMPASS="Ericom123$"
GITBRANCH_FIX=""
GITBRANCH2=$BRANCH

function usage() {
    echo "USAGE: $0 [--pre-use] [--update] [--deploy] [--no-get-custom] [--uninstall] [--delete-all]"
    echo "    --update         : Shield のバージョンを変更できます。"
    echo "    --deploy         : Rancherクラスタが構成済みの環境で、Shieldの展開のみを行います。"
    echo "    --spell-check-on : ブラウザのスペルチェック機能をONの状態でセットアップします。"
    echo "                        ※日本語環境ではメモリリークの原因になるためデフォルトOFFです。"
    echo "    --no-get-custom  : helm展開時のcustom yamlファイルを新規に取得しません。"
    echo "    --uninstall      : Shield のみをアンインストールします。 --deploy により再展開できます。"
    echo "    --delete-all     : Rancherを含めて全てのコンテナを削除します。クラスタも破棄します。"

    exit 0
    ### for Develop only
    # [--staging | --dev] [--version <Chart version>] [--pre-use] [--gitbranch]
    ##
}

function check_group() {
    log_message "[start] check group"
    docker_flg=0
    for GROUP in $(groups $USER | cut -d: -f2)
    do
        if [ "docker" == "$GROUP" ]; then
            if [ ! $(docker info) >/dev/null 2>&1 ]; then
                echo "================================================================================="
                echo "一度ログオフした後、ログインをしなおして、スクリプトを再度実行してください。"
                echo "================================================================================="
                fin 1
            fi
            docker_flg=1
            break
        fi
    done

    if [ $docker_flg -eq 0 ]; then
        echo ""
        echo "================================================================================="
        echo "実行ユーザをdockerグループに追加する必要があります。"
        echo "追加後、セットアップスクリプトは中断します。"
        echo "一度ログオフした後、ログインをしなおして、スクリプトを再度実行してください。"
        echo "================================================================================="
        log_message "[start] add group"
        sudo usermod -aG docker "$USER"
        log_message "[end] add group"
        fin 1
    fi

    log_message "[end] check group"
}


function check_args(){
    pre_flg=0
    args=""
    dev_flg=0
    stg_flg=1
    ver_flg=0
    git_flg=0
    update_flg=0
    deploy_flg=0
    noget_flg=0
    spell_flg=0
    uninstall_flg=0
    deleteall_flg=0
    APP_VERSION=""

    for i in `seq 1 ${#}`
    do
        if [ "$1" == "--pre-use" ]; then
            pre_flg=1
        elif [ "$1" == "--help" ] || [ "$1" == "-h" ] ; then
            usage
        elif [ "$1" == "--update" ] || [ "$1" == "--Update" ] ; then
            update_flg=1
        elif [ "$1" == "--deploy" ] || [ "$1" == "--Deploy" ] ; then
            deploy_flg=1
        elif [ "$1" == "--no-get-custom" ] || [ "$1" == "--No-get-custom" ] ; then
            noget_flg=1
        elif [ "$1" == "--spell-check-on" ] || [ "$1" == "--Spell-check-on" ] ; then
            spell_flg=1
        elif [ "$1" == "--uninstall" ] || [ "$1" == "--Uninstall" ] ; then
            uninstall_flg=1
        elif [ "$1" == "--delete-all" ] || [ "$1" == "--Delete-all" ]  || [ "$1" == "--Delete-All" ] ; then
            deleteall_flg=1
        elif [ "$1" == "--dev" ] || [ "$1" == "--Dev" ] ; then
            dev_flg=1
        elif [ "$1" == "--staging" ] || [ "$1" == "--Staging" ] ; then
            stg_flg=1
        elif [ "$1" == "--gitbranch" ] ; then
            shift
            GITBRANCH="$1"
            git_flg=1
        elif [ "$1" == "-v" ] || [ "$1" == "--version" ] || [ "$1" == "--Version" ]; then
            shift
            APP_VERSION="$1"
            ver_flg=1
        else
            args="${args} ${1}"
        fi
        shift
    done

    if [ $dev_flg -eq 1 ] ; then
        if [ $BRANCH != "Dev" ] ; then
            BRANCH="Dev"
        fi
    elif [ $stg_flg -eq 1 ] ; then
        if  [ $BRANCH != "Staging" ] ; then
            BRANCH="Staging"
        fi
    fi

    if [ "$GITBRANCH_FIX" == "" ]; then
        GITBRANCH=$BRANCH
    else
        GITBRANCH=$GITBRANCH_FIX
    fi
    GITBRANCH2=$BRANCH

    export BRANCH
    export GITBRANCH
    export GITBRANCH2

    log_message "BRANCH: $BRANCH"
    echo "GITBRANCH: $GITBRANCH" >> $LOGFILE
    echo "GITBRANCH2: $GITBRANCH2" >> $LOGFILE

}


function uninstall_shield() {
    log_message "[start] uninstall shield"

    curl -s -o delete-shield.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/delete-shield.sh
    chmod +x delete-shield.sh
    sudo ./delete-shield.sh

    log_message "[end] uninstall shield"
}
function delete_all() {
    log_message "[start] deletel all object"

    curl -s -o delete-all.sh https://ericom-tec.ashisuto.co.jp/shield/delete-all.sh
    chmod +x delete-all.sh
    sudo ./delete-all.sh

    log_message "[end] deletel all object"

    echo '------------------------------------------------------------'
    echo "(【必要に応じて】, 下記を他のノードでも実行してください。)"
    echo ""
    echo "curl -s -o delete-all.sh https://ericom-tec.ashisuto.co.jp/shield/delete-all.sh"
    echo 'chmod +x delete-all.sh'
    echo 'sudo ./delete-all.sh'
    echo ""
    echo '------------------------------------------------------------'
}


function add_repo() {
    case $BRANCH in
        "master") BRANCHFLG=""
                 ;;
        "Staging") BRANCHFLG="-s"
                 ;;
        "Dev") BRANCHFLG="-d"
                 ;;
    esac

    log_message "[start] add shield repo"
    curl -s -o add-shield-repo.sh  https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/add-shield-repo.sh
    chmod +x add-shield-repo.sh
    ./add-shield-repo.sh ${BRANCHFLG} -p ${ERICOMPASS} > /dev/null
}


function deploy_shield() {
    log_message "[start] deploy shield"

    curl -s -o deploy-shield.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/deploy-shield.sh
    chmod +x deploy-shield.sh

    sed -i -e '/^VERSION_REPO/d' deploy-shield.sh
    sed -i -e '/^SET_LABELS=\"/s/yes/no/g' deploy-shield.sh
    sed -i -e '/^BRANCH=/d' deploy-shield.sh
    sed -i -e '/^helm search/d' deploy-shield.sh
    sed -i -e '/helm upgrade --install/s/shield-repo\/shield/shield-repo\/shield --version \${VERSION_REPO}/g' deploy-shield.sh
    sed -i -e '/VERSION_DEPLOYED/s/\$9/\$10/g' deploy-shield.sh
    sed -i -e '/VERSION_DEPLOYED/s/helm list shield/helm list shield-management/g' deploy-shield.sh
    #sed -i -e '/curl.*yaml/d' deploy-shield.sh

    if [ $noget_flg -ne 1 ]; then
        curl -s -o custom-farm.yaml https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH2}/Kube/scripts/custom-farm.yaml
        curl -s -o custom-management.yaml https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH2}/Kube/scripts/custom-management.yaml
        curl -s -o custom-proxy.yaml https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH2}/Kube/scripts/custom-proxy.yaml
        curl -s -o custom-values-elk.yaml https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH2}/Kube/scripts/custom-values-elk.yaml
    fi

    if [ $spell_flg -ne 1 ]; then
        sed -i -e 's/^#farm-services/farm-services/' custom-farm.yaml
        sed -i -e 's/^#.*DISABLE_SPELL_CHECK/  DISABLE_SPELL_CHECK/' custom-farm.yaml
    fi

    if [ $deploy_flg -eq 1 ]; then
        sed -i -e '/Same Versions/{n;s/exit/#exit/}' deploy-shield.sh
    fi

    select_version

    VERSION_REPO=$APP_VERSION
    export VERSION_REPO

    ./deploy-shield.sh

    curl -s -o deploy-shield.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/deploy-shield.sh

    log_message "[end] deploy shield"
}


function failed_to_install() {
    log_message "An error occurred during the installation: $1, exiting"
    fin 1
}


function log_message() {
    local PREV_RET_CODE=$?
    echo "$@"
    echo "$(LC_ALL=C date): $@" >>"$LOGFILE"
    if ((PREV_RET_CODE != 0)); then
        return 1
    fi
    return 0
}


function choose_network_interface() {
    local INTERFACES=($(find /sys/class/net -type l -not -lname '*virtual*' -printf '%f\n'))
    local INTERFACE_ADDRESSES=()
    local OPTIONS=()

    for IFACE in "${INTERFACES[@]}"; do
        OPTIONS+=("Name: \"$IFACE\", IP address: $(/sbin/ip address show scope global dev $IFACE | grep -oP '(?<=inet )\d+\.\d+\.\d+\.\d+')")
        INTERFACE_ADDRESSES+=("$(/sbin/ip address show scope global dev $IFACE | grep -oP '(?<=inet )\d+\.\d+\.\d+\.\d+')")
    done

    if ((${#OPTIONS[@]} == 0)); then
        log_message "No network interface cards detected. Aborting!"
        exit 1
    elif ((${#OPTIONS[@]} == 1)); then
        local REPLY=1
        log_message "Using ${INTERFACES[$((REPLY - 1))]} with address ${INTERFACE_ADDRESSES[$((REPLY - 1))]} as an interface"
        MY_IP="${INTERFACE_ADDRESSES[$((REPLY - 1))]}"
        return
    fi

    echo "Choose a network card to be used by Shield"
    PS3="Enter your choice: "
    select opt in "${OPTIONS[@]}" "Quit"; do

        case "$REPLY" in

        [1-$((${#OPTIONS[@]}))]*)
            log_message "Using ${INTERFACES[$((REPLY - 1))]} with address ${INTERFACE_ADDRESSES[$((REPLY - 1))]} as an interface"
            MY_IP="${INTERFACE_ADDRESSES[$((REPLY - 1))]}"
            return
            ;;
        $((${#OPTIONS[@]} + 1)))
            break
            ;;
        *)
            echo "Invalid option. Try another one."
            continue
            ;;
        esac
    done

    failed_to_install "choose_network_interface"
}


function fin() {
    log_message "###### DONE ############################################################"
    exit $1
}


## JAPAN ONLY ##########################################
function select_version() {
    CHART_VERSION=""

    VERSION_DEPLOYED=$(helm list shield-management | awk '{ print $10 }')
    VERSION_DEPLOYED=`echo ${VERSION_DEPLOYED} | sed -e "s/[\r\n]\+//g"`
    echo "=================================================================="
    if [ -z $VERSION_DEPLOYED ]; then
        echo "現在インストールされているバージョン: N/A"
    else
        echo "現在インストールされているバージョン: Rel-$VERSION_DEPLOYED"
    fi
    echo "=================================================================="

    if [ $pre_flg -eq 1 ] ; then
        CHART_VERSION=$(curl -s https://ericom-tec.ashisuto.co.jp/shield/k8s-pre-rel-ver.txt | awk '{ print $1 }')
        APP_VERSION=$(curl -s https://ericom-tec.ashisuto.co.jp/shield/k8s-pre-rel-ver.txt | awk '{ print $2 }')
        if [ "$CHART_VERSION" == "NA" ]; then
            echo "現在ご利用可能なリリース前先行利用バージョンはありません。"
            exit 1
        else
            echo -n "リリース前先行利用バージョン Rel-${APP_VERSION} をセットアップします。[Y/n]:"
            read ANSWER
            case $ANSWER in
                "" | "Y" | "y" | "yes" | "Yes" | "YES" ) echo "Start."
                                                         ;;
                * ) echo "STOP."
                    exit 1
                    ;;
            esac
        fi
    fi

    if [ $ver_flg -eq 1 ] ; then
            CHART=(${APP_VERSION//./ })
            CHART_VERSION="${CHART[0]}.$(( 10#${CHART[1]} )).${CHART[2]}"
    else
        declare -A vers_c
        declare -A vers_a
        n=0
        m=0

        if [ "$BRANCH" == "Dev" ]; then
            VER=$(helm search -l shield | grep -v CHART | awk '{printf "%s %s\n", $2,$3}')
        else
            VER=$(curl -s https://ericom-tec.ashisuto.co.jp/shield/${BRANCH}-k8s-rel-ver.txt | grep -v CHART | awk '{printf "%s %s\n", $2,$3}')
        fi

        echo "どのバージョンをセットアップしますか？"
        for i in $VER
        do
            n=$(( $n + 1 ))
            if [ $((${n} % 2)) = 0 ]; then
                m=$(( $n / 2 ))
                APP_VERSION=$i
                vers_a[$m]=$APP_VERSION
                echo "$m: Rel-$APP_VERSION"
            else
                if [ $n = 1 ]; then
                    m=1
                else
                    m=$(( $n - $m ))
                fi
                CHART_VERSION=$i
                vers_c[$m]=$CHART_VERSION
            fi
        done

        while :
        do
            echo
            echo -n " 番号で指定してください: "
            read answer
            if [[ -z ${vers_c[$answer]} ]] ; then
                    echo "番号が違っています。"
            else
                    CHART_VERSION=${vers_c[$answer]}
                    APP_VERSION=${vers_a[$answer]}
                    break
            fi
        done
    fi

    echo "Rel-${APP_VERSION} をセットアップします。"
}
## JAPAN ONLY ##########################################


if [ "$1" == "--help" ] || [ "$1" == "-h" ] ; then
    usage
fi


log_message "###### START ###########################################################"

#OS Check
if [ -f /etc/redhat-release ]; then
    OS="RHEL"
else
    OS="Ubuntu"
fi

# check args and set flags
check_args $@

#uninstall
if [ $uninstall_flg -eq 1 ]; then
    uninstall_shield
    fin 0
fi

#delete all
if [ $deleteall_flg -eq 1 ]; then
    uninstall_shield
    delete_all
    fin 0
fi

#update or deploy
if [ $update_flg -eq 1 ] || [ $deploy_flg -eq 1 ]; then
    add_repo
    deploy_shield
    fin 0
fi

# set MY_IP
choose_network_interface

# set sysctl

log_message "[start] setting sysctl-values"
curl -s -o configure-sysctl-values.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/Staging/Kube/scripts/configure-sysctl-values.sh
chmod +x configure-sysctl-values.sh
sudo ./configure-sysctl-values.sh
log_message "[end] setting sysctl-values"

# install docker
log_message "[start] install docker"
curl -s -o install-docker.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/install-docker.sh
chmod +x install-docker.sh

APP_VERSION=$(cat ./install-docker.sh | grep APP_VERSION= |cut -d= -f2)
APP_VERSION=$(echo $APP_VERSION | sed "s/\"//g")
APP_VER=(${APP_VERSION//./ })
if [ -x "/usr/bin/docker" ]; then
    INSTALLED_VERSION=$(docker info |grep "Server Version" | awk '{print $3}')
else
    INSTALLED_VERSION="0.0.0"
fi
INSTALLED_VER=(${INSTALLED_VERSION//./ })


if [[ ${INSTALLED_VER[0]}  -gt ${APP_VER[0]} ]]; then
    log_message "$INSTALLED_VERSION > $APP_VERSION"
elif  [[ ${INSTALLED_VER[0]} -lt ${APP_VER[0]} ]]; then
    log_message "$INSTALLED_VERSION < $APP_VERSION"
    ./install-docker.sh >>"$LOGFILE" 2>&1
else
    if [[ ${INSTALLED_VER[1]}  -gt ${APP_VER[1]} ]]; then
        log_message "$INSTALLED_VERSION > $APP_VERSION"
    elif  [[ ${INSTALLED_VER[1]}  -lt ${APP_VER[1]} ]]; then
        log_message "$INSTALLED_VERSION < $APP_VERSION"
        ./install-docker.sh >>"$LOGFILE" 2>&1
    elif [[ ${INSTALLED_VER[1]}  -eq ${APP_VER[1]} ]]; then
        log_message "$INSTALLED_VERSION = $APP_VERSION"
    fi
fi

log_message "[end] install docker"

# docker guroup check
check_group

# install jq
log_message "[start] install jq"
if [[ $OS == "Ubuntu" ]]; then
    sudo apt-get install -y -qq jq >>"$LOGFILE" 2>&1
elif [[ $OS == "RHEL" ]]; then
    sudo yum -y -q install epel-release
    sudo yum -y -q install jq
fi
log_message "[end] install jq"

## set Rancer URL & ports
log_message "[start] set Rancer URL & ports"
#
#echo ""
#echo "================================================================================="
#echo 'この"Racnher"ノード (場合によっては "Cluster Manger" を含む）に'
#echo '"Worker node" (Ericom Shield) を一緒にインストールしますか？(非推奨) [y/N]:'
#echo "================================================================================="
#while :
#do
#    read ANSWER
#    case $ANSWER in
#        "Y" | "y" | "yse" | "Yes" | "YES" )
#            RANCHERHTTPPORT="8080"
            RANCHERHTTPSPORT="8443"
#            break
#            ;;
#        "" | "n" | "N" | "no" | "No" | "NO" )
#            RANCHERHTTPPORT="80"
#            RANCHERHTTPSPORT="443"
#            break
#            ;;
#        * )
#            echo "Please answer with Y or N."
#            ;;
#    esac
#done
#
RANCHERURL="https://${MY_IP}:${RANCHERHTTPSPORT}"
echo "================================================================================="
log_message "[set] RANCHERURL: $RANCHERURL"
echo "================================================================================="
log_message "[end] set Rancer URL & ports"

## run rancher
#log_message "[start] run rancher"
#mkdir -p ~/rancher-store
#docker run -d --restart=unless-stopped \
#  -p 8443:443 \
#  -v ~/rancher-store:/var/lib/rancher \
#  rancher/rancher:latest
#log_message "[end] run rancher"


# run rancher
log_message "[start] run rancher"
curl -s -o run-rancher.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/Staging/Kube/scripts/run-rancher.sh
chmod +x run-rancher.sh
./run-rancher.sh
log_message "[end] run rancher"



# wait launched rancher
log_message "[waiting] launched rancher"
while ! curl -s -k "${RANCHERURL}/ping"; do sleep 3; done
echo ""

curl -s -o run-rancher.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/Staging/Kube/scripts/run-rancher.sh
chmod +x run-rancher.sh
./run-rancher.sh


# Rabcer first Login
LOGINRESPONSE=$(curl -s -k "${RANCHERURL}/v3-public/localProviders/local?action=login" \
    -H 'content-type: application/json' \
    --data-binary '{
        "username":"admin",
        "password":"admin"
      }' \
    )
LOGINTOKEN=$(echo $LOGINRESPONSE | jq -r .token)

log_message "LOGINTOKEN: $LOGINTOKEN"

# Change password
while :
do
    echo ""
    echo "================================================================================="
    echo  'Rancher の admin ユーザのパスワードを新しくセットしてください。 : '
    echo "================================================================================="
    read -s PASSWORD
    echo -n '確認の為もう一度入力してください。 : '
    read -s PASSWORD2
    if [ $PASSWORD = $PASSWORD2 ]; then
        break
    else
        echo "入力したパスワードが一致しません。"
    fi
done

curl -s -k "${RANCHERURL}/v3/users?action=changepassword" \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $LOGINTOKEN" \
    --data-binary '{
        "currentPassword":"admin",
        "newPassword":"'$PASSWORD'"
      }' \
   >>"$LOGFILE" 2>&1
log_message "[end] Change password"

# Create API key
APIRESPONSE=$(curl -s -k "${RANCHERURL}/v3/token" \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $LOGINTOKEN" \
    --data-binary '{
        "type":"token",
        "description":"automation"
      }' \
    )

# Extract and store token
APITOKEN=$(echo $APIRESPONSE | jq -r .token)
log_message "APITOKEN: $APITOKEN"
log_message "[end] Create API key"

# Set server-url
curl -s -k "${RANCHERURL}/v3/settings/server-url" \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $APITOKEN" \
    -X PUT \
    --data-binary '{
        "name":"server-url",
        "value":"'$RANCHERURL'"
      }' \
   >>"$LOGFILE" 2>&1
log_message "[end] Set server-url"

# Create cluster
echo ""
echo "================================================================================="
echo  'クラスタ名を設定してください。(任意の名前) : '
echo "================================================================================="
read CLUSTERNAME
CLUSTERRESPONSE=$(curl -s -k "${RANCHERURL}/v3/cluster" \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $APITOKEN" \
    --data-binary '{
        "dockerRootDir": "/var/lib/docker",
        "enableNetworkPolicy": false,
        "type": "cluster",
        "rancherKubernetesEngineConfig": {
          "addonJobTimeout": 30,
          "ignoreDockerVersion": true,
          "sshAgentAuth": false,
          "type": "rancherKubernetesEngineConfig",
          "authentication": {
            "type": "authnConfig",
            "strategy": "x509"
          },
          "network": {
            "options": {
              "flannel_backend_type": "vxlan"
             },
            "type": "networkConfig",
            "plugin": "calico"
          },
          "ingress": {
            "type": "ingressConfig",
            "provider": "nginx"
          },
          "monitoring": {
            "type": "monitoringConfig",
            "provider": "metrics-server"
          },
          "services": {
            "type": "rkeConfigServices",
            "kubeApi": {
              "podSecurityPolicy": false,
              "type": "kubeAPIService"
            },
            "etcd": {
              "snapshot": false,
              "type": "etcdService",
              "extraArgs": {
                "heartbeat-interval": 500,
                "election-timeout": 5000
              }
            }
          }
        },
        "name": "'${CLUSTERNAME}'"
      }' \
    )

# Extract clusterid
CLUSTERID=$(echo $CLUSTERRESPONSE | jq -r .id)
log_message "CLUSTERID: $CLUSTERID"
log_message "[end] Extract clusterid "

# create cluster regist token
curl -s -k "${RANCHERURL}/v3/clusterregistrationtoken" \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $APITOKEN" \
    --data-binary '{
        "type":"clusterRegistrationToken",
        "clusterId":"'$CLUSTERID'"
      }' \
   >>"$LOGFILE" 2>&1

# Set role flags
declare -A roles
roles[1]='--etcd --controlplane --worker'
roles[2]='--etcd --controlplane'
roles[3]='--worker'

while :
do
    echo ""
    echo "========================================================================================="
    echo 'このノードに何をセットアップしますか？ 番号で選んでください。'
    echo '1) 全て (Rancher, Cluster Management および Ericom Shield)'
    echo '2) Rancher and Cluster Management (Ericom Shield を除く)'
    echo '3) Rancher のみ'
    echo ""
    echo "★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★"
    echo '※この選択の後、複数台構成にする場合に他のノードで実行するコマンドが画面に表示されます。'
    echo '※必要に応じてコピーの上、他ノードで実行してください。'
    echo "★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★"
    echo ""
    echo "========================================================================================="
    read ANSWERNO
    if [[ -z ${roles[$ANSWERNO]} ]]; then
        echo "番号が正しくありません。"
        echo ""
    else
        ROLEFLAGS=${roles[$ANSWERNO]}
        break
    fi
done

# Generate nodecommand
AGENTCMD=$(curl -s -k "${RANCHERURL}/v3/clusterregistrationtoken?id=${CLUSTERID}" \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $APITOKEN" \
    | jq -r '.data[].nodeCommand' | head -1)

# Concat commands
DOCKERRUNCMD1="$AGENTCMD ${roles[1]}"
DOCKERRUNCMD2="$AGENTCMD ${roles[2]}"
DOCKERRUNCMD3="$AGENTCMD ${roles[3]}"

echo "" >>"$LOGFILE"
echo "=================================================================================" >>"$LOGFILE"
echo "DOCKERRUNCMD1: $DOCKERRUNCMD1" >>"$LOGFILE"
echo "" >>"$LOGFILE"
echo "DOCKERRUNCMD2: $DOCKERRUNCMD2" >>"$LOGFILE"
echo "" >>"$LOGFILE"
echo "DOCKERRUNCMD3: $DOCKERRUNCMD3" >>"$LOGFILE"
echo "=================================================================================" >>"$LOGFILE"
echo "" >>"$LOGFILE"
log_message "[end] Concat commands"

# Exec docker command
log_message "[start] Exec docker command "

echo ""
echo "★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★"
case $ANSWERNO in
    "1") DOCKERRUNCMD=$DOCKERRUNCMD1
         echo '下記のコマンドがこのノードで実行されます。(確認用。実行の必要はありません。)'
         echo ""
         echo "$DOCKERRUNCMD1"
         echo ""
         echo '------------------------------------------------------------'
         echo 'そして、'
         echo '(【必要に応じて】 下記コマンドを他のオールインワンノードで実行してください。)'
         echo ""
         echo "curl -s -o install-docker.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/install-docker.sh"
         echo 'chmod +x install-docker.sh'
         echo './install-docker.sh'
         echo ""
         echo "curl -s -o configure-sysctl-values.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH2}/Kube/scripts/configure-sysctl-values.sh"
         echo 'chmod +x configure-sysctl-values.sh'
         echo 'sudo ./configure-sysctl-values.sh'
         echo ""
         echo "$DOCKERRUNCMD1"
         echo ""
         echo '------------------------------------------------------------'
         echo 'または、'
         echo '(【必要に応じて】 下記コマンドを他の Cluster Management ノードで実行してください。)'
         echo ""
         echo "curl -s -o install-docker.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/install-docker.sh"
         echo 'chmod +x install-docker.sh'
         echo './install-docker.sh'
         echo ""
         echo "$DOCKERRUNCMD2"
         echo ""
         echo '------------------------------------------------------------'
         echo 'または、'
         echo '(【必要に応じて】 下記コマンドを他の Worker ノードで実行してください。)'
         echo ""
         echo "curl -s -o install-docker.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/install-docker.sh"
         echo 'chmod +x install-docker.sh'
         echo './install-docker.sh'
         echo ""
         echo "curl -s -o configure-sysctl-values.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH2}/Kube/scripts/configure-sysctl-values.sh"
         echo 'chmod +x configure-sysctl-values.sh'
         echo 'sudo ./configure-sysctl-values.sh'
         echo ""
         echo "$DOCKERRUNCMD3"
         echo ""
         ;;
    "2") DOCKERRUNCMD=$DOCKERRUNCMD2
         echo '下記のコマンドがこのノードで実行されます。(確認用。実行の必要はありません。)'
         echo ""
         echo "$DOCKERRUNCMD2"
         echo ""
         echo '------------------------------------------------------------'
         echo 'そして、'
         echo '(【必要に応じて】 下記コマンドを他の Cluster Management ノードで実行してください。)'
         echo ""
         echo "curl -s -o install-docker.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/install-docker.sh"
         echo 'chmod +x install-docker.sh'
         echo './install-docker.sh'
         echo ""
         echo "$DOCKERRUNCMD2"
         echo ""
         echo '------------------------------------------------------------'
         echo 'そして、'
         echo '(【必要に応じて】 下記コマンドを他の Worker ノードで実行してください。)'
         echo ""
         echo "curl -s -o install-docker.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/install-docker.sh"
         echo 'chmod +x install-docker.sh'
         echo './install-docker.sh'
         echo ""
         echo "curl -s -o configure-sysctl-values.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH2}/Kube/scripts/configure-sysctl-values.sh"
         echo 'chmod +x configure-sysctl-values.sh'
         echo 'sudo ./configure-sysctl-values.sh'
         echo ""
         echo "$DOCKERRUNCMD3"
         echo ""
         ;;
    "3") DOCKERRUNCMD=""
         echo '下記コマンドを Cluster Management ノードで実行してください。'
         echo ""
         echo "curl -s -o install-docker.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/install-docker.sh"
         echo 'chmod +x install-docker.sh'
         echo './install-docker.sh'
         echo ""
         echo "$DOCKERRUNCMD2"
         echo ""
         echo '------------------------------------------------------------'
         echo 'そして'
         echo '下記コマンドを WORKER ノードで実行してください。'
         echo ""
         echo "curl -s -o install-docker.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/install-docker.sh"
         echo 'chmod +x install-docker.sh'
         echo './install-docker.sh'
         echo ""
         echo "curl -s -o configure-sysctl-values.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH2}/Kube/scripts/configure-sysctl-values.sh"
         echo 'chmod +x configure-sysctl-values.sh'
         echo 'sudo ./configure-sysctl-values.sh'
         echo ""
         echo "$DOCKERRUNCMD3"
         echo ""
        ;;
esac
echo ""
echo "★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★"

$DOCKERRUNCMD > /dev/null

while :
do
echo ""
echo "================================================================================="
echo 'それぞれのノードでコマンドの実行は完了しましたか？'
echo '先に進んでもよろしいですか？ [y/N]:'
echo "================================================================================="
    read ANSWER
    case $ANSWER in
        "Y" | "y" | "yse" | "Yes" | "YES" )
            break
            ;;
        "" | "n" | "N" | "no" | "No" | "NO" )
            ;;
        * )
            echo "YまたはNで答えて下さい。"
            ;;
    esac
done

# waiting cluster to active
log_message "[waiting] Cluster to active"

while :
    do
       CLUSTERSTATE=$(curl -s -k "${RANCHERURL}/v3/clusters/${CLUSTERID}" -H "Authorization: Bearer $APITOKEN" | jq -r .state)
       echo "Waiting for state to become active.: $CLUSTERSTATE"
       if [ "active" = "$CLUSTERSTATE" ] ;then
           break
       fi
       sleep 10
done

log_message "[end] Exec docker command "


# install kubectl
log_message "[start] install kubectl "
if [[ $OS == "Ubuntu" ]]; then
    sudo rm -f "/etc/apt/sources.list.d/kubernetes.list"
elif  [[ $OS == "RHEL" ]]; then
    sudo rm -f "/etc/yum.repos.d/kubernetes.repo"
fi
curl -s -o install-kubectl.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/install-kubectl.sh
chmod +x install-kubectl.sh
./install-kubectl.sh  >> $LOGFILE
log_message "[end] install kubectl "

# Get kubectl config
log_message "[start] Get kubectl config"
touch  ~/.kube/config
curl -s -k "${RANCHERURL}/v3/clusters/${CLUSTERID}?action=generateKubeconfig" \
    -X POST  \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $APITOKEN" \
    | jq -r .config > ~/.kube/config
log_message "[end] Get kubectl config"
log_message "$(kubectl version)"


# install helm
log_message "[start] install helm "
curl -s -o install-helm.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH}/Kube/scripts/install-helm.sh
chmod +x install-helm.sh
./install-helm.sh > /dev/null
log_message "[end] install helm "

# get System project id
log_message "[start] get System project id"
SYSPROJECTID=$(curl -s -k "${RANCHERURL}/v3/projects/?name=System" \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $APITOKEN" \
    | jq -r '.data[].id')
log_message "SYSPROJECTID: $SYSPROJECTID"
log_message "[end] get System project id"

# waiting tiller pod
log_message "[start]  waiting tiller pod "
while :
    do
       TILLERSTATE=$(curl -s -k "${RANCHERURL}/v3/project/${SYSPROJECTID}/workloads/deployment:kube-system:tiller-deploy" -H "Authorization: Bearer $APITOKEN" | jq -r .deploymentStatus.availableReplicas)
       echo "Waiting for state to become available.: $TILLERSTATE"
       if [[ $TILLERSTATE -ge 1 ]] ;then
           break
       fi
       sleep 10
done
log_message "[end]  waiting tiller pod "

# add shield repo
add_repo

#log_message "$(helm search shield)"
log_message "[end] add shield repo"

if [ "1" = "$ANSWERNO" ]; then
    # configure sysctl
    log_message "[start] configure sysctl"
    curl -s -o configure-sysctl-values.sh https://raw.githubusercontent.com/EricomSoftwareLtd/Shield/${GITBRANCH2}/Kube/scripts/configure-sysctl-values.sh
    sudo chmod +x configure-sysctl-values.sh
    sudo ./configure-sysctl-values.sh > /dev/null
    log_message "[end] configure sysctl"
fi

# set node label
NODELIST=($(kubectl get node -o json |jq -r .items[].metadata.name))

for NODENAME in ${NODELIST[@]};
do
    echo ""
    while :
    do
    echo "================================================================================="
        echo "*** {$NODENAME} ***"
        echo '上記ノードにどのShieldコンポーネントを配置しますか？ 番号で選択してください。'
        echo '0) Cluster Management のみ'
        echo '1) 全て (farm-services, remort-browsers, management, proxy, elk)'
        echo '2) System Component (farm-services, management, proxy, elk)'
        echo '3) 【elkを除く】 全て (farm-services, remort-browsers, management, proxy)'
        echo '4) 【elkを除く】 System Component(farm-services, management, proxy)'
        echo '5) ELK のみ (elk)'
        echo '6) Browser のみ (remort-browsers)'
        echo '7) Browser Farm (farm-services, remort-browsers)'
        read LABELNO

        case $LABELNO in
            "0")
                break
                ;;
            "1")
                kubectl label node ${NODENAME} shield-role/farm-services=accept --overwrite
                kubectl label node ${NODENAME} shield-role/remote-browsers=accept --overwrite
                kubectl label node ${NODENAME} shield-role/management=accept --overwrite
                kubectl label node ${NODENAME} shield-role/proxy=accept --overwrite
                kubectl label node ${NODENAME} shield-role/elk=accept --overwrite
                break
                ;;
            "2")
                kubectl label node ${NODENAME} shield-role/farm-services=accept --overwrite
                kubectl label node ${NODENAME} shield-role/management=accept --overwrite
                kubectl label node ${NODENAME} shield-role/proxy=accept --overwrite
                kubectl label node ${NODENAME} shield-role/elk=accept --overwrite
                break
                ;;
            "3")
                kubectl label node ${NODENAME} shield-role/farm-services=accept --overwrite
                kubectl label node ${NODENAME} shield-role/remote-browsers=accept --overwrite
                kubectl label node ${NODENAME} shield-role/management=accept --overwrite
                kubectl label node ${NODENAME} shield-role/proxy=accept --overwrite
                break
                ;;
            "4")
                kubectl label node ${NODENAME} shield-role/farm-services=accept --overwrite
                kubectl label node ${NODENAME} shield-role/management=accept --overwrite
                kubectl label node ${NODENAME} shield-role/proxy=accept --overwrite
                break
                ;;
            "5")
                kubectl label node ${NODENAME} shield-role/elk=accept --overwrite
                break
                ;;
            "6")
                kubectl label node ${NODENAME} shield-role/remote-browsers=accept --overwrite
                break
                ;;
            "7")
                kubectl label node ${NODENAME} shield-role/farm-services=accept --overwrite
                kubectl label node ${NODENAME} shield-role/remote-browsers=accept --overwrite
                break
                ;;
            *)
                echo "番号が正しくありません。"
                ;;
        esac
    done
done

# deploy shield
deploy_shield

# get Default project id
log_message "[start] get Default project id"
DEFPROJECTID=$(curl -s -k "${RANCHERURL}/v3/projects/?name=Default" \
    -H 'content-type: application/json' \
    -H "Authorization: Bearer $APITOKEN" \
    | jq -r '.data[].id')
log_message "DEFPROJECTID: $DEFPROJECTID"
log_message "[end] get Default project id"

# move namespases to Default project
log_message "[start] Move namespases to Default project"

for NAMESPACE in management proxy elk farm-services
do
    curl -s -k "${RANCHERURL}/v3/cluster/${CLUSTERID}/namespaces/${NAMESPACE}?action=move" \
        -H 'content-type: application/json' \
        -H "Authorization: Bearer $APITOKEN" \
        --data-binary '{
            "projectId":"'$DEFPROJECTID'"
          }' \
       >>"$LOGFILE" 2>&1

    log_message "move namespases to Default project/ ${NAMESPACE} "
done

log_message "[end] Move namespases to Default project"

curl -s -o shield-status.sh https://ericom-tec.ashisuto.co.jp/shield/shield-status.sh
chmod +x shield-status.sh

fin 0


